<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: ECMAScript class brand check proposal
stage: 1
contributors: HE Shi-Jun, XU Tian-Yang, Tu Qiang
</pre>

<emu-clause id="sec-ecmascript-data-types-and-values">
  <h1>ECMAScript Data Types and Values</h1>
  <emu-clause id="sec-ecmascript-specification-types">
    <h1>ECMAScript Specification Types</h1>
    <emu-clause id="sec-object-type">
      <h1>The Object Type</h1>
      <emu-clause id="sec-object-internal-methods-and-internal-slots">
        <h1>Object Internal Methods and Internal Slots</h1>
        <p>
          <ins>
            All objects have an internal slot named [[ClassBrands]],
            which is a List of class brand.
            Initially, it is an empty List.
          </ins>
        </p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-syntax-directed-operations">
  <h1>Syntax-Directed Operations</h1>

  <emu-clause id="sec-syntax-directed-operations-contains">
    <h1>Contains</h1>

    <emu-clause id="sec-static-semantics-contains" oldids="sec-object-initializer-static-semantics-contains,sec-static-semantics-static-semantics-contains,sec-function-definitions-static-semantics-contains,sec-arrow-function-definitions-static-semantics-contains,sec-generator-function-definitions-static-semantics-contains,sec-async-generator-function-definitions-static-semantics-contains,sec-class-definitions-static-semantics-contains,sec-async-function-definitions-static-semantics-Contains,sec-async-arrow-function-definitions-static-semantics-Contains" type="sdo">
      <h1>
        Static Semantics: Contains (
          _symbol_: unknown,
        )
      </h1>
      <dl class="header">
      </dl>
      <p>Every grammar production alternative in this specification which is not listed below implicitly has the following default definition of Contains:</p>
      <emu-alg>
        1. For each child node _child_ of this Parse Node, do
          1. If _child_ is an instance of _symbol_, return *true*.
          1. If _child_ is an instance of a nonterminal, then
            1. Let _contained_ be the result of _child_ Contains _symbol_.
            1. If _contained_ is *true*, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. <ins>If _symbol_ is |ClassHasInstanceCall|, then</ins>
          1. <ins>If |FormalParameters| Contains _symbol_ is *true*, return *true*.</ins>
          1. <ins>If |FunctionBody| of a |FunctionDeclaration| Contains _symbol_ is *true*, return *true*.</ins>
          1. <ins>If |FunctionBody| of a |FunctionExpression| Contains _symbol_ is *true*, return *true*.</ins>
          1. <ins>If |GeneratorBody| of a |GeneratorDeclaration| Contains _symbol_ is *true*, return *true*.</ins>
          1. <ins>If |GeneratorBody| of a |GeneratorExpression| Contains _symbol_ is *true*, return *true*.</ins>
          1. <ins>If |AsyncGeneratorBody| of an |AsyncGeneratorDeclaration| Contains _symbol_ is *true*, return *true*.</ins>
          1. <ins>If |AsyncGeneratorBody| of an |AsyncGeneratorExpression| Contains _symbol_ is *true*, return *true*.</ins>
          1. <ins>If |AsyncFunctionBody| of an |AsyncFunctionDeclaration| Contains _symbol_ is *true*, return *true*.</ins>
          1. <ins>If |AsyncFunctionBody| of an |AsyncFunctionExpression| Contains _symbol_ is *true*, return *true*.</ins>
        1. Return *false*.
      </emu-alg>
      <emu-note>
        <p>Static semantic rules that depend upon substructure generally do not look into function definitions <ins>except for |ClassHasInstanceCall|s</ins>.</p>
      </emu-note>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, <ins>|ClassHasInstanceCall|,</ins> `super` or `this`, return *false*.
        1. If |ArrowParameters| Contains _symbol_ is *true*, return *true*.
        1. Return |ConciseBody| Contains _symbol_.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, <ins>|ClassHasInstanceCall|,</ins> `super`, or `this`, return *false*.
        1. Return |AsyncConciseBody| Contains _symbol_.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, <ins>|ClassHasInstanceCall|,</ins> `super`, or `this`, return *false*.
        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.
        1. If _head_ Contains _symbol_ is *true*, return *true*.
        1. Return |AsyncConciseBody| Contains _symbol_.
      </emu-alg>
      <emu-note>
        <p>Contains is used to detect `new.target`, <ins>`class.hasInstance`,</ins> `this`, and `super` usage within an |ArrowFunction| or |AsyncArrowFunction|.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-miscellaneous">
    <h1>Miscellaneous</h1>

    <emu-clause id="sec-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>

      <emu-grammar type="definition">
        CallExpression :
          CoverCallExpressionAndAsyncArrowHead
          SuperCall
          ImportCall
          <ins>ClassHasInstanceCall</ins>
          CallExpression Arguments
          CallExpression TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-executable-code-and-execution-contexts">
  <h1>Executable Code and Execution Contexts</h1>
  <emu-clause id="sec-environment-records" oldids="sec-lexical-environments">
    <h1>Environment Records</h1>
    <emu-clause id="sec-the-environment-record-type-hierarchy">
      <h1>The Environment Record Type Hierarchy</h1>
      <emu-clause id="sec-class-environment-records">
        <h1><ins>Class Environment Records</ins></h1>
        <p>A <dfn>class Environment Record</dfn> is a declarative Environment Record that is used to represent the top-level scope of a class, used to perform `class.hasInstance` meta method invocations from within the class.</p>
        <p>Class Environment Records have the additional state fields listed in <emu-xref href="#table-additional-fields-of-class-environment-records"></emu-xref>.</p>
        <emu-table id="table-additional-fields-of-class-environment-records" caption="Additional Fields of Class Environment Records">
          <table>
            <tbody>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[ClassConstructor]]
              </td>
              <td>
                Object
              </td>
              <td>
                The class constructor whose definition caused this Environment Record to be created.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <p>Class Environment Records support all of the declarative Environment Record methods listed in <emu-xref href="#table-18"></emu-xref> and share the same specifications for all of those methods.</p>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-environment-record-operations" oldids="sec-lexical-environment-operations">
      <h1>Environment Record Operations</h1>

      <emu-clause id="sec-newclassenvironment" aoid="NewClassEnvironment">
        <h1><ins>NewClassEnvironment ( E )</ins></h1>
        <p>The abstract operation NewClassEnvironment takes argument E (an Environment Record). It performs the following steps when called:</p>
        <emu-alg>
          1. Let _env_ be a new class Environment Record containing no bindings.
          1. Set _env_.[[OuterEnv]] to _E_.
          1. Return _env_.
        </emu-alg>
      </emu-clause>

    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-execution-contexts">
    <h1>Execution Contexts</h1>
    <emu-clause id="sec-getclassenvironment" aoid="GetClassEnvironment">
      <h1><ins>GetClassEnvironment ( )</ins></h1>
      <p>The abstract operation GetClassEnvironment takes no arguments. It finds the Class Environment Record of the nearest containing class. It performs the following steps when called:</p>
      <emu-alg>
        1. Let _envRec_ be the running execution context's LexicalEnvironment.
        1. Repeat,
          1. If _envRec_ is a Class Environment Record, return _envRec_.
          1. Let _envRec_ be _envRec_.[[OuterEnv]].
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ordinary-and-exotic-objects-behaviours">
  <h1>Ordinary and Exotic Objects Behaviours</h1>

  <emu-clause id="sec-ecmascript-function-objects">
    <h1>ECMAScript Function Objects</h1>
    <p>ECMAScript function objects encapsulate parameterized ECMAScript code closed over a lexical environment and support the dynamic evaluation of that code. An ECMAScript function object is an ordinary object and has the same internal slots and the same internal methods as other ordinary objects. The code of an ECMAScript function object may be either strict mode code (<emu-xref href="#sec-strict-mode-code"></emu-xref>) or non-strict code. An ECMAScript function object whose code is strict mode code is called a <dfn id="strict-function" variants="strict functions">strict function</dfn>. One whose code is not strict mode code is called a <dfn id="non-strict-function" variants="non-strict functions">non-strict function</dfn>.</p>
    <p>In addition to [[Extensible]] and [[Prototype]], ECMAScript function objects also have the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>.</p>
    <emu-table id="table-internal-slots-of-ecmascript-function-objects" caption="Internal Slots of ECMAScript Function Objects" oldids="table-27">
      <table>
        <tr>
          <th>
            Internal Slot
          </th>
          <th>
            Type
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            [[Environment]]
          </td>
          <td>
            Environment Record
          </td>
          <td>
            The Environment Record that the function was closed over. Used as the outer environment when evaluating the code of the function.
          </td>
        </tr>
        <tr>
          <td>
            [[PrivateEnvironment]]
          </td>
          <td>
            PrivateEnvironment Record | *null*
          </td>
          <td>
            The PrivateEnvironment Record for Private Names that the function was closed over. *null* if this function is not syntactically contained within a class. Used as the outer PrivateEnvironment for inner classes when evaluating the code of the function.
          </td>
        </tr>
        <tr>
          <td>
            [[FormalParameters]]
          </td>
          <td>
            Parse Node
          </td>
          <td>
            The root parse node of the source text that defines the function's formal parameter list.
          </td>
        </tr>
        <tr>
          <td>
            [[ECMAScriptCode]]
          </td>
          <td>
            Parse Node
          </td>
          <td>
            The root parse node of the source text that defines the function's body.
          </td>
        </tr>
        <tr>
          <td>
            [[ConstructorKind]]
          </td>
          <td>
            ~base~ | ~derived~
          </td>
          <td>
            Whether or not the function is a derived class constructor.
          </td>
        </tr>
        <tr>
          <td>
            [[Realm]]
          </td>
          <td>
            Realm Record
          </td>
          <td>
            The realm in which the function was created and which provides any intrinsic objects that are accessed when evaluating the function.
          </td>
        </tr>
        <tr>
          <td>
            [[ScriptOrModule]]
          </td>
          <td>
            Script Record or Module Record
          </td>
          <td>
            The script or module in which the function was created.
          </td>
        </tr>
        <tr>
          <td>
            [[ThisMode]]
          </td>
          <td>
            ~lexical~ | ~strict~ | ~global~
          </td>
          <td>
            Defines how `this` references are interpreted within the formal parameters and code body of the function. ~lexical~ means that `this` refers to the *this* value of a lexically enclosing function. ~strict~ means that the *this* value is used exactly as provided by an invocation of the function. ~global~ means that a *this* value of *undefined* or *null* is interpreted as a reference to the global object, and any other *this* value is first passed to ToObject.
          </td>
        </tr>
        <tr>
          <td>
            [[Strict]]
          </td>
          <td>
            Boolean
          </td>
          <td>
            *true* if this is a strict function, *false* if this is a non-strict function.
          </td>
        </tr>
        <tr>
          <td>
            [[HomeObject]]
          </td>
          <td>
            Object
          </td>
          <td>
            If the function uses `super`, this is the object whose [[GetPrototypeOf]] provides the object where `super` property lookups begin.
          </td>
        </tr>
        <tr>
          <td>
            [[SourceText]]
          </td>
          <td>
            sequence of Unicode code points
          </td>
          <td>
            The <emu-xref href="#sec-source-text">source text</emu-xref> that defines the function.
          </td>
        </tr>
        <tr>
          <td>
            [[Fields]]
          </td>
          <td>
            List of ClassFieldDefinition Records
          </td>
          <td>
            If the function is a class, this is a list of Records representing the non-static fields and corresponding initializers of the class.
          </td>
        </tr>
        <tr>
          <td>
            [[PrivateMethods]]
          </td>
          <td>
            List of PrivateElements
          </td>
          <td>
            If the function is a class, this is a list representing the non-static private methods and accessors of the class.
          </td>
        </tr>
        <tr>
          <td>
            [[ClassFieldInitializerName]]
          </td>
          <td>
            String | Symbol | Private Name | ~empty~
          </td>
          <td>
            If the function is created as the initializer of a class field, the name to use for NamedEvaluation of the field; ~empty~ otherwise.
          </td>
        </tr>
        <tr>
          <td>
            [[IsClassConstructor]]
          </td>
          <td>
            Boolean
          </td>
          <td>
            Indicates whether the function is a class constructor. (If *true*, invoking the function's [[Call]] will immediately throw a *TypeError* exception.)
          </td>
        </tr>
        <tr>
          <td>
            <ins>[[ClassBrand]]</ins>
          </td>
          <td>
            <ins>a globally unique value | ~empty~</ins>
          </td>
          <td>
            <ins>If the function is a class, this might be a globally unique value; ~empty~ otherwise.</ins>
          </td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-ecmascript-function-objects-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        )
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>an ECMAScript function object _F_</dd>
      </dl>
      <emu-alg>
        1. Let _callerContext_ be the running execution context.
        1. Let _kind_ be _F_.[[ConstructorKind]].
        1. If _kind_ is ~base~, then
          1. Let _thisArgument_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Object.prototype%"*).
        1. Let _calleeContext_ be PrepareForOrdinaryCall(_F_, _newTarget_).
        1. Assert: _calleeContext_ is now the running execution context.
        1. If _kind_ is ~base~, then
          1. Perform OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_).
          1. Let _initializeResult_ be InitializeInstanceElements(_thisArgument_, _F_).
          1. If _initializeResult_ is an abrupt completion, then
            1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
            1. Return Completion(_initializeResult_).
        1. Let _constructorEnv_ be the LexicalEnvironment of _calleeContext_.
        1. Let _result_ be OrdinaryCallEvaluateBody(_F_, _argumentsList_).
        1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
        1. <ins>If _F_.[[ClassBrand]] is not ~empty~:</ins>
          1. <ins>Let _currentThisResult_ be _constructorEnv_.GetThisBinding()</ins>
          1. <ins>If _result_.[[Type]] is not ~throw~ and _currentThisResult_.[[Type]] is not ~throw~, then append _F_.[[ClassBrand]] to _currentThisResult_.[[Value]].[[ClassBrands]].</ins>
        1. If _result_.[[Type]] is ~return~, then
          1. If Type(_result_.[[Value]]) is Object, return NormalCompletion(_result_.[[Value]]).
          1. If _kind_ is ~base~, return NormalCompletion(_thisArgument_).
          1. If _result_.[[Value]] is not *undefined*, throw a *TypeError* exception.
        1. Else, ReturnIfAbrupt(_result_).
        1. Return ? _constructorEnv_.GetThisBinding().
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ordinaryfunctioncreate" aoid="OrdinaryFunctionCreate" oldids="sec-functionallocate,sec-functioninitialize,sec-functioncreate,sec-generatorfunctioncreate,sec-asyncgeneratorfunctioncreate,sec-async-functions-abstract-operations-async-function-create">
      <h1>OrdinaryFunctionCreate ( _functionPrototype_, _sourceText_, _ParameterList_, _Body_, _thisMode_, _Scope_ )</h1>
      <p>The abstract operation OrdinaryFunctionCreate takes arguments _functionPrototype_ (an Object), _sourceText_ (a sequence of Unicode code points), _ParameterList_ (a Parse Node), _Body_ (a Parse Node), _thisMode_ (either ~lexical-this~ or ~non-lexical-this~), and _Scope_ (an Environment Record). _sourceText_ is the source text of the syntactic definition of the function to be created. It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: Type(_functionPrototype_) is Object.
        1. Let _internalSlotsList_ be the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>.
        1. Let _F_ be ! OrdinaryObjectCreate(_functionPrototype_, _internalSlotsList_).
        1. Set _F_.[[Call]] to the definition specified in <emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref>.
        1. Set _F_.[[SourceText]] to _sourceText_.
        1. Set _F_.[[FormalParameters]] to _ParameterList_.
        1. Set _F_.[[ECMAScriptCode]] to _Body_.
        1. If the source text matching _Body_ is strict mode code, let _Strict_ be *true*; else let _Strict_ be *false*.
        1. Set _F_.[[Strict]] to _Strict_.
        1. If _thisMode_ is ~lexical-this~, set _F_.[[ThisMode]] to ~lexical~.
        1. Else if _Strict_ is *true*, set _F_.[[ThisMode]] to ~strict~.
        1. Else, set _F_.[[ThisMode]] to ~global~.
        1. Set _F_.[[IsClassConstructor]] to *false*.
        1. <ins>Set _F_.[[ClassBrand]] to ~empty~.</ins>
        1. Set _F_.[[Environment]] to _Scope_.
        1. Set _F_.[[ScriptOrModule]] to GetActiveScriptOrModule().
        1. Set _F_.[[Realm]] to the current Realm Record.
        1. Set _F_.[[HomeObject]] to *undefined*.
        1. Let _len_ be the ExpectedArgumentCount of _ParameterList_.
        1. Perform ! SetFunctionLength(_F_, _len_).
        1. Return _F_.
      </emu-alg>
    </emu-clause>

  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-left-hand-side-expressions">
    <h1>Left-Hand-Side Expressions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      CallExpression[Yield, Await] :
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover
        SuperCall[?Yield, ?Await]
        ImportCall[?Yield, ?Await]
        <ins>ClassHasInstanceCall[?Yield, ?Await]</ins>
        CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        CallExpression[?Yield, ?Await] `.` IdentifierName
        CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        CallExpression[?Yield, ?Await] `.` PrivateIdentifier

      <ins>ClassHasInstanceCall[Yield, Await] :</ins>
        `class` `.` `hasInstance` `(` AssignmentExpression[+In, ?Yield, ?Await] `,`? `)`
    </emu-grammar>

    <emu-clause id="sec-meta-methods">
      <h1><ins>Meta Methods</ins></h1>
      <emu-clause id="sec-class-keyword-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evalutaion</h1>
        <emu-grammar>
          ClassHasInstanceCall :
            `class` `.` `hasInstance` `(` AssignmentExpression `,`? `)`
        </emu-grammar>
        <emu-alg>
          1. Let _inst_ be the result of |AssignmentExpression|.
          1. If Type(_inst_) is not Object.
            1. Return *false*.
          1. Let _envRec_ be GetClassEnvironment()
          1. Let _C_ be _envRec_.[[ClassConstructor]].
          1. Assert: _C_.[[ClassBrand]] is not ~empty~.
          1. If _inst_.[[ClassBrands]] includes _C_.[[ClassBrand]], then
            1. Return *true*.
          1. Else,
            1. Return *false*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-functions-and-classes">
  <h1>ECMAScript Language: Functions and Classes</h1>
  <emu-clause id="sec-class-definitions">
    <h1>Class Definitions</h1>

    <emu-clause id="sec-class-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody `}`</emu-grammar>
      <ul>
        <li>
          <p>It is a Syntax Error if |ClassHeritage| is not present and the following algorithm evaluates to *true*:</p>
          <emu-alg>
            1. Let _constructor_ be ConstructorMethod of |ClassBody|.
            1. If _constructor_ is ~empty~, return *false*.
            1. Return HasDirectSuper of _constructor_.
          </emu-alg>
        </li>
        <li>
          <p><ins>It is a Syntax Error if |ClassHeritage| is present and |ClassHeritage| Contains |ClassHasInstanceCall|.</ins></p>
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-ContainsClassHasInstance" type="sdo" aoid="ContainsClassHasInstance">
      <h1><ins>Static Semantics: ContainsClassHasInstance</ins></h1>

      <emu-grammar>
        ClassBody[Yield, Await] :
          ClassElementList[?Yield, ?Await]
      </emu-grammar>
      <emu-alg>
        1. Return ContainsClassHasInstance of |ClassElementList|.
      </emu-alg>

      <emu-grammar>
        ClassElementList[Yield, Await] :
          ClassElement[?Yield, ?Await]
      </emu-grammar>
      <emu-alg>
        1. Return ContainsClassHasInstance of |ClassElement|.
      </emu-alg>

      <emu-grammar>
        ClassElementList[Yield, Await] :
          ClassElementList[?Yield, ?Await] ClassElement[?Yield, ?Await]
      </emu-grammar>
      <emu-alg>
        1. If ContainsClassHasInstance of |ClassElement| is *true*, return *true*.
        1. Return ContainsClassHasInstance of |ClassElement|.
      </emu-alg>

      <emu-grammar>
        ClassElement :
          MethodDefinition
          `static` MethodDefinition
      </emu-grammar>
      <emu-alg>
        1. Return ContainsClassHasInstance of |MethodDefinition|.
      </emu-alg>

      <emu-grammar>
        ClassElement:
          FieldDefinition
          `static` FieldDefinition
      </emu-grammar>
      <emu-alg>
        1. Return ContainsClassHasInstance of |FieldDefintion|.
      </emu-alg>

      <emu-grammar>
        MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |ClassHasInstanceCall| is *true*, return *true*.
        2. Return |FunctionBody| Contains |ClassHasInstanceCall|.
      </emu-alg>

      <emu-grammar>MethodDefinition : `get` ClassElementName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return |FunctionBody| Contains |ClassHasInstanceCall|.
      </emu-alg>

      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. If |PropertySetParameterList| Contains |ClassHasInstanceCall| is *true*, return *true*.
        1. Return |FunctionBody| Contains |ClassHasInstanceCall|.
      </emu-alg>

      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |ClassHasInstanceCall| is *true*, return *true*.
        1. Return |GeneratorBody| Contains |ClassHasInstanceCall|.
      </emu-alg>

      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |ClassHasInstanceCall| is *true*, return *true*.
        1. Return |AsyncGeneratorBody| Contains |ClassHasInstanceCall|.
      </emu-alg>

      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |ClassHasInstanceCall| is *true*, return *true*.
        1. Return |AsyncFunctionBody| Contains |ClassHasInstanceCall|.
      </emu-alg>

      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. If |Initializer_opt| is not preset, return *false*.
        1. Return ContainsClassHasInstance of |Initializer|.
      </emu-alg>

      <emu-grammar>
        Initializer :
          `=` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. Return |AssignmentExpression| Contains |ClassHasInstanceCall|
      </emu-alg>

    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classdefinitionevaluation" oldids="sec-default-constructor-functions" type="sdo">
      <h1>
        Runtime Semantics: ClassDefinitionEvaluation (
          _classBinding_: unknown,
          _className_: unknown,
        )
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>For ease of specification, private methods and accessors are included alongside private fields in the [[PrivateElements]] slot of class instances. However, any given object has either all or none of the private methods and accessors defined by a given class. This feature has been designed so that implementations may choose to implement private methods and accessors using a strategy which does not require tracking each method or accessor individually.</p>
        <p>For example, an implementation could directly associate instance private methods with their corresponding Private Name and track, for each object, which class constructors have run with that object as their `this` value. Looking up an instance private method on an object then consists of checking that the class constructor which defines the method has been used to initialize the object, then returning the method associated with the Private Name.</p>
        <p>This differs from private fields: because field initializers can throw during class instantiation, an individual object may have some proper subset of the private fields of a given class, and so private fields must in general be tracked individually.</p>
      </emu-note>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
      <emu-alg>
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _classEnv_ be New<del>Declarative</del><ins>Class</ins>Environment(_env_).
        1. If _classBinding_ is not *undefined*, then
          1. Perform _classEnv_.CreateImmutableBinding(_classBinding_, *true*).
        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.
        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).
        1. If |ClassBody?| is present, then
          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody?|, do
            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name whose [[Description]] is _dn_, then
              1. Assert: This is only possible for getter/setter pairs.
            1. Else,
              1. Let _name_ be a new Private Name whose [[Description]] value is _dn_.
              1. Append _name_ to _classPrivateEnvironment_.[[Names]].
        1. If |ClassHeritage?| is not present, then
          1. Let _protoParent_ be %Object.prototype%.
          1. Let _constructorParent_ be %Function.prototype%.
        1. Else,
          1. Set the running execution context's LexicalEnvironment to _classEnv_.
          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.
          1. Let _superclassRef_ be the result of evaluating |ClassHeritage|.
          1. Set the running execution context's LexicalEnvironment to _env_.
          1. Let _superclass_ be ? GetValue(_superclassRef_).
          1. If _superclass_ is *null*, then
            1. Let _protoParent_ be *null*.
            1. Let _constructorParent_ be %Function.prototype%.
          1. Else if IsConstructor(_superclass_) is *false*, throw a *TypeError* exception.
          1. Else,
            1. Let _protoParent_ be ? Get(_superclass_, *"prototype"*).
            1. If Type(_protoParent_) is neither Object nor Null, throw a *TypeError* exception.
            1. Let _constructorParent_ be _superclass_.
        1. Let _proto_ be ! OrdinaryObjectCreate(_protoParent_).
        1. If |ClassBody?| is not present, let _constructor_ be ~empty~.
        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.
        1. Set the running execution context's LexicalEnvironment to _classEnv_.
        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.
        1. If _constructor_ is ~empty~, then
          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:
            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].
            1. If NewTarget is *undefined*, throw a *TypeError* exception.
            1. Let _F_ be the active function object.
            1. If _F_.[[ConstructorKind]] is ~derived~, then
              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.
              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().
              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.
              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).
            1. Else,
              1. NOTE: This branch behaves similarly to `constructor() {}`.
              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Object.prototype%"*).
            1. Perform ? InitializeInstanceElements(_result_, _F_).
            1. Return _result_.
          1. Let _F_ be ! CreateBuiltinFunction(_defaultConstructor_, 0, _className_, &laquo; [[ConstructorKind]], [[SourceText]] &raquo;, the current Realm Record, _constructorParent_).
        1. Else,
          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.
          1. Let _F_ be _constructorInfo_.[[Closure]].
          1. Perform ! MakeClassConstructor(_F_).
          1. Perform ! SetFunctionName(_F_, _className_).
        1. Perform ! MakeConstructor(_F_, *false*, _proto_).
        1. If |ClassHeritage?| is present, set _F_.[[ConstructorKind]] to ~derived~.
        1. Perform ! CreateMethodProperty(_proto_, *"constructor"*, _F_).
        1. <ins>Set _classEnv_.[[ClassConstructor]] to _F_.</ins>
        1. <ins>If |ClassBody?| is present, then</ins>
          1. <ins>If ContainsClassHasInstance of |ClassBody|, Set _F_.[[ClassBrand]] to a new unique value.</ins>
        1. If |ClassBody?| is not present, let _elements_ be a new empty List.
        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.
        1. Let _instancePrivateMethods_ be a new empty List.
        1. Let _staticPrivateMethods_ be a new empty List.
        1. Let _instanceFields_ be a new empty List.
        1. Let _staticElements_ be a new empty List.
        1. For each |ClassElement| _e_ of _elements_, do
          1. If IsStatic of _e_ is *false*, then
            1. Let _element_ be ClassElementEvaluation of _e_ with argument _proto_.
          1. Else,
            1. Let _element_ be ClassElementEvaluation of _e_ with argument _F_.
          1. If _element_ is an abrupt completion, then
            1. Set the running execution context's LexicalEnvironment to _env_.
            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
            1. Return Completion(_element_).
          1. Set _element_ to _element_.[[Value]].
          1. If _element_ is a PrivateElement, then
            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.
            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.
            1. Else, let _container_ be _staticPrivateMethods_.
            1. If _container_ contains a PrivateElement whose [[Key]] is _element_.[[Key]], then
              1. Let _existing_ be that PrivateElement.
              1. Assert: _element_.[[Kind]] and _existing_.[[Kind]] are both ~accessor~.
              1. If _element_.[[Get]] is *undefined*, then
                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _existing_.[[Get]], [[Set]]: _element_.[[Set]] }.
              1. Else,
                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _existing_.[[Set]] }.
              1. Replace _existing_ in _container_ with _combined_.
            1. Else,
              1. Append _element_ to _container_.
          1. Else if _element_ is a ClassFieldDefinition Record, then
            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.
            1. Else, append _element_ to _staticElements_.
          1. Else if _element_ is a ClassStaticBlockDefinition Record, then
            1. Append _element_ to _staticElements_.
        1. Set the running execution context's LexicalEnvironment to _env_.
        1. If _classBinding_ is not *undefined*, then
          1. Perform _classEnv_.InitializeBinding(_classBinding_, _F_).
        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.
        1. Set _F_.[[Fields]] to _instanceFields_.
        1. For each PrivateElement _method_ of _staticPrivateMethods_, do
          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).
        1. For each element _elementRecord_ of _staticElements_, do
          1. If _elementRecord_ is a ClassFieldDefinition Record, then
            1. Let _result_ be DefineField(_F_, _elementRecord_).
          1. Else,
            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.
            1. Let _result_ be ? Call(_elementRecord_.[[BodyFunction]], _F_).
          1. If _result_ is an abrupt completion, then
            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
            1. Return _result_.
        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
        1. Return _F_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript Language: Scripts and Modules</h1>
  <emu-clause id="sec-scripts">
    <h1>Scripts</h1>
    <emu-clause id="sec-scripts-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>

      <emu-grammar>ScriptBody : StatementList</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if |StatementList| Contains `super` unless the source code containing `super` is eval code that is being processed by a direct eval. Additional early error rules for `super` within direct eval are defined in <emu-xref href="#sec-performeval"></emu-xref>.
          </li>
          <li>
            It is a Syntax Error if |StatementList| Contains |NewTarget| unless the source code containing |NewTarget| is eval code that is being processed by a direct eval. Additional early error rules for |NewTarget| in direct eval are defined in <emu-xref href="#sec-performeval"></emu-xref>.
          </li>
          <li>
            <ins>It is a Syntax Error if |StatementList| Contains |ClassHasInstanceCall|.</ins>
          </li>
          <li>
            It is a Syntax Error if ContainsDuplicateLabels of |StatementList| with argument &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedBreakTarget of |StatementList| with argument &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedContinueTarget of |StatementList| with arguments &laquo; &raquo; and &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if AllPrivateIdentifiersValid of |StatementList| with argument &laquo; &raquo; is *false* unless the source code containing |ScriptBody| is eval code that is being processed by a direct eval.
          </li>
        </ul>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>
    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>
      <emu-clause id="sec-module-semantics-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the LexicallyDeclaredNames of |ModuleItemList| contains any duplicate entries.
          </li>
          <li>
            It is a Syntax Error if any element of the LexicallyDeclaredNames of |ModuleItemList| also occurs in the VarDeclaredNames of |ModuleItemList|.
          </li>
          <li>
            It is a Syntax Error if the ExportedNames of |ModuleItemList| contains any duplicate entries.
          </li>
          <li>
            It is a Syntax Error if any element of the ExportedBindings of |ModuleItemList| does not also occur in either the VarDeclaredNames of |ModuleItemList|, or the LexicallyDeclaredNames of |ModuleItemList|.
          </li>
          <li>
            It is a Syntax Error if |ModuleItemList| Contains `super`.
          </li>
          <li>
            It is a Syntax Error if |ModuleItemList| Contains |NewTarget|.
          </li>
          <li>
            <ins>It is a Syntax Error if |ModuleItemList| Contains |ClassHasInstanceCall|.</ins>
          </li>
          <li>
            It is a Syntax Error if ContainsDuplicateLabels of |ModuleItemList| with argument &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedBreakTarget of |ModuleItemList| with argument &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedContinueTarget of |ModuleItemList| with arguments &laquo; &raquo; and &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if AllPrivateIdentifiersValid of |ModuleItemList| with argument &laquo; &raquo; is *false*.
          </li>
        </ul>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
